## 索引

假设一张表有一亿条记录，在没有索引的情况下，我们查找数据需要遍历每一条数据，但是加了索引，它就能快速定位，这是为什么呢？



索引的底层结构是B+树，B+树是平衡树的一种

```
平衡树：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
```



我们给字段建一个新索引， 字段中的数据就会被复制一份出来， 用于生成索引树，存储结构就由整齐排列的结构转变成了树状结构，也就是上面说的「平衡树」，有了这棵（假设这棵树有10层），那么只需要10次IO开销就能找到需要数据，比起一亿次，效率是不是大大提升了。



## 聚集和非聚集索引、覆盖索引

简单概括：

- 聚集索引就是以**主键**创建的索引
- 非聚集索引就是以**非主键**创建的索引，非聚集索引也叫二级索引



一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐， 跟我认知中的「表」很接近。如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是上面说的「平衡树」结构，换句话说，就是整个表就变成了一个索引。没错， 再说一遍， 整个表变成了一个索引，也就是所谓的「聚集索引」。



非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值

![image-20200217155449283](C:\Users\jiang\AppData\Roaming\Typora\typora-user-images\image-20200217155449283.png)



不管以任何方式查询表， 最终都会利用主键通过聚集索引来定位到数据， 聚集索引（主键）是通往真实数据所在的唯一路径。

然而， 有一种例外可以不使用聚集索引就能查询出所需要的数据， 这种非主流的方法 称之为「覆盖索引」查询



覆盖索引

select user_name from user_info where birthday = '1991-11-1'

create index index_birthday_and_user_name on user_info(birthday, user_name);



执行过程：

通过非聚集索引index_birthday_and_user_name查找birthday等于1991-11-1的叶节点的内容，然而， 叶节点中除了有user_name表主键ID的值以外， user_name字段的值也在里面， 因此不需要通过主键ID值的查找数据行的真实所在， 直接取得叶节点中user_name的值返回即可。 通过这种覆盖索引直接查找的方式， 可以省略不使用覆盖索引查找的后面两个步骤， 大大的提高了查询性能







### 带有主键和 三个非聚集索引的表的存储结构

![image-20200217160641022](C:\Users\jiang\AppData\Roaming\Typora\typora-user-images\image-20200217160641022.png)



索引树结构中各节点的值来自于表中的索引字段， 假如给user表的name字段加上索引 ， 那么索引就是由name字段中的值构成







#### 索引的类型

在MySQL中，索引分为两大类：聚簇索引和非聚簇索引。聚簇索引是按照数据存放的物理位置为顺序的，而非聚簇索引则不同；聚簇索引能够提高多行检索的速度，而非聚簇索引则对单行的检索速度很快。

在这两大类的索引类型下，还可以将索引分成四个小类：

1，普通索引：最基本的索引，没有任何限制，是我们大多数情况下使用到的索引。

2，唯一索引：与普通索引类型，不同的是唯一索引的列值必须唯一，但允许为空值。

3，全文索引：全文索引（FULLTEXT）仅可以适用于MyISAM引擎的数据表；作用于CHAR、VARCHAR、TEXT数据类型的列。

4，组合索引：将几个列作为一条索引进行检索，使用最左匹配原则。





## 索引总结

索引在数据库中是一个**非常**重要的知识点！上面谈的其实就是索引**最基本**的东西，要创建出好的索引要顾及到很多的方面：

- 1，**最左前缀匹配原则**。这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，MySQL会一直向右匹配直到遇到范围查询`（>,<,BETWEEN,LIKE）`就停止匹配。
- 3，尽量选择**区分度高的列作为索引**，区分度的公式是 `COUNT(DISTINCT col) / COUNT(*)`。表示字段不重复的比率，比率越大我们扫描的记录数就越少。
- 4，**索引列不能参与计算，尽量保持列“干净”**。比如，`FROM_UNIXTIME(create_time) = '2016-06-06'` 就不能使用索引，原因很简单，**B+树中存储的都是数据表中的字段值**，但是进行检索时，需要把所有元素都应用函数才能比较，显然这样的代价太大。所以语句要写成 ： `create_time = UNIX_TIMESTAMP('2016-06-06')`。
- 5，尽可能的**扩展索引**，不要新建立索引。比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。
- 6，单个多列组合索引和多个单列索引的检索查询效果不同，因为在执行SQL时，**MySQL只能使用一个索引**，会从多个单列索引中选择一个限制最为严格的索引。





学习链接：

https://juejin.im/post/5b55b842f265da0f9e589e79#heading-20

https://zhuanlan.zhihu.com/p/23624390

https://blog.csdn.net/mysteryhaohao/article/details/51719871