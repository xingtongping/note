Class本质是二进制流，8个字节为基础单位
javap  -verbose   ...class

相关内容博客
https://www.cnblogs.com/buwuliao/p/10646763.html


类加载机制：
加载-验证-准备-解析-初始化-使用-卸载
初始化：有且只有5种情况才必须对类进行初始化
1、new、getstatic、putstatic、invokestatic     get set static变量 调用static方法
2、对类进行反射调用
3、初始化一个类，但是父类还有初始化的时候，先触发父类的
4、指定一个执行main的类，主类
5、动态语言支持

准备：给成员变量（类变量/静态变量）赋默认值 int value = 0;
　　　　把常量（final)等值在方法区的常量池中给准备好。

解析：由符号引用变为直接（地址）引用
比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language


类加载：
1、加载二进制流
2、把静态存储结构转化为方法区的运行时结构
3、生成一个代表这个类的class对象

准备阶段： int value = 123；
准备：int value = 0；
初始化：value = 123；

初始化:执行类的构造器<clinit> 构造器 常量
初始化过程的主要操作是执行静态代码块和初始化静态域。
在一个类被初始化之前，它的直接父类也需要被初始化





系统的类加载器:
1、启动类加载器-bootstrap ClassLoader   java_home/lib中
2、扩展类加载器-Extension ClassLoader   java_home/lib /ext 或配置指定目录
3、应用程序class加载器-Application Loader   程序默认的类加载器


双亲委派模型
某个加载器接到加载请求，首先将加载任务委托给父类加载器，依次递归，如果父类可以完成加载，就成功返回，无法完成才自己去加载。
一个类是否唯一，由类本身和类加载器一起决定
如果不是双亲委派，用户定义个java.lang.Object，程序出现两个不同的Object，目的就是保证java程序稳定运行



双亲委派模型
1）避免核心API被篡改

2）避免类的重复加载

loadclass方法实现了双亲委派

tomcat有自己的类加载器



栈帧
当前栈帧
局部变量表
操作帧
动态链接
返回地址


方法调用详解
解析
静态方法、构造方法、私有方法

分派
1、静态分派--方法重载
static class Human{}
Human h1 = new Man()  由静态类型决定，编译期间不知道是哪个实例的方法	
h1.sayhello	

解析和静态分派都在编译期间确定了调用哪个

2、动态分派--子类覆盖（重写）了父类的方法，表现子类行为（可以想象，覆盖了父类方法表，都指向了子类方法代码）
3、动态分派的实现--虚方法表（由虚拟机维护，维护着各个方法的实际入口）


动态分派在运行时期才知道具体调用哪个方法



双亲委派模型破坏
jdbc模式下   由启动类加载器反过来调用应用程序类
com.mysql.jdbc.Driver肯定不在<JAVA_HOME>/lib下，所以肯定是无法加载mysql中的这个类的
这个mysql的drvier只有应用类加载器能加载，那么我们只要在启动类加载器中有方法获取应用程序类加载器，然后通过它去加载就可以了。这就是所谓的线程上下文加载器。
即由启动类加载器获取应用程序类加载器来加载


操作数帧
虚拟机把操作数栈作为它的工作区——大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。比如，iadd指令就要从操作数栈中弹出两个整数，执行加法运算




http://www.360doc.com/content/21/1215/15/78125985_1008832205.shtml

方法区：类信息   运行时常量池
加载过程是把class字节码文件加载到内存中南
加载  验证：结构  准备：静态属性分配内存，设置默认初始值  解析：符号引用替换成直接引用，指向目标的指针
启动类 扩展类 应用程序类
栈：一个方法一个栈帧，对应一块内存区域。调用入栈，结束出栈，每个栈帧包含：局部变量表，操作数栈，动态连接，方法返回地址，一些附加信息
