Class本质是二进制流，8个字节为基础单位
javap  -verbose   ...class


类加载机制：
加载-验证-准备-解析-初始化-使用-卸载
初始化：有且只有5种情况才必须对类进行初始化
1、new、getstatic、putstatic、invokestatic     get set static变量 调用static方法
2、对类进行反射调用
3、初始化一个类，但是父类还有初始化的时候，先触发父类的
4、指定一个执行main的类，主类
5、动态语言支持


类加载：
1、加载二进制流
2、把静态存储结构转化为方法区的运行时结构
3、生成一个代表这个类的class对象

准备阶段： int value = 123；
准备：int value = 0；
初始化：value = 123；

初始化:执行类的构造器<clinit> 构造器 常量





系统的类加载器:
1、启动类加载器-bootstrap ClassLoader   java_home/lib中
2、扩展类加载器-Extension ClassLoader   java_home/lib /ext
3、应用程序class加载器-Application Loader   程序默认的类加载器


双亲委派模型
某个加载器接到加载请求，首先将加载任务委托给父类加载器，依次递归，如果父类可以完成加载，就成功返回，无法完成才自己去加载。
一个类是否唯一，由类本身和类加载器一起决定
如果不是双亲委派，用户定义个java.lang.Object，程序出现两个不同的Object，目的就是保证java程序稳定运行



双亲委派模型
1）避免核心API被篡改

2）避免类的重复加载

loadclass方法实现了双亲委派

tomcat有自己的类加载器



栈帧
当前栈帧
局部变量表
操作帧
动态链接
返回地址


方法调用详解
解析
静态方法、构造方法、私有方法

分派
1、静态分派--方法重载
static class Human{}
Human h1 = new Man()  由静态类型决定，编译期间不知道是哪个实例的方法	
h1.sayhello	

解析和静态分派都在编译期间确定了调用哪个

2、动态分派--子类覆盖（重写）了父类的方法，表现子类行为（可以想象，覆盖了父类方法表，都指向了子类方法代码）
3、动态分派的实现--虚方法表（由虚拟机维护，维护着各个方法的实际入口）


动态分派在运行时期才知道具体调用哪个方法



双亲委派模型破坏
jdbc模式下   由启动类加载器反过来调用应用程序类
com.mysql.jdbc.Driver肯定不在<JAVA_HOME>/lib下，所以肯定是无法加载mysql中的这个类的
这个mysql的drvier只有应用类加载器能加载，那么我们只要在启动类加载器中有方法获取应用程序类加载器，然后通过它去加载就可以了。这就是所谓的线程上下文加载器。
即由启动类加载器获取应用程序类加载器来加载


操作数帧
虚拟机把操作数栈作为它的工作区——大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。比如，iadd指令就要从操作数栈中弹出两个整数，执行加法运算



